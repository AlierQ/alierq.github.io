<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MVC设计模式</title>
    <link href="/posts/7333197b.html"/>
    <url>/posts/7333197b.html</url>
    
    <content type="html"><![CDATA[<h2 id="MVC设计模模式"><a href="#MVC设计模模式" class="headerlink" title="MVC设计模模式"></a>MVC设计模模式</h2><h3 id="什么是设计模式？"><a href="#什么是设计模式？" class="headerlink" title="什么是设计模式？"></a>什么是设计模式？</h3><p>设计模式是软件开发人员在软件开发过程中面临一般问题的解决方案，是一套被反复使用的、多数人知晓的、代码设计的总结。使用设计模式能够使得代码更可靠、更易懂、更高效。</p><h3 id="什么是MVC设计模式？"><a href="#什么是MVC设计模式？" class="headerlink" title="什么是MVC设计模式？"></a>什么是MVC设计模式？</h3><p>MVC设计模式为了提高代码的灵活性和复用性，将应用划分为三个部分：</p><ol><li>Model（模型） 这部分封装了应用程序业务逻辑相关的数据以及他们对应的处理数据的方法，当数据发生改变时模型将会通知数据相关的视图。</li></ol><p>Model示例：</p>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Model</span> = &#123;<br>    <span class="hljs-attr">data</span>:&#123;&#125;,     <span class="hljs-comment">// 数据</span><br>    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>)&#123;&#125;,     <span class="hljs-comment">// 获取数据</span><br>    <span class="hljs-title function_">save</span>(<span class="hljs-params"></span>)&#123;&#125;,    <span class="hljs-comment">// 保存数据</span><br>    <span class="hljs-title function_">create</span>(<span class="hljs-params"></span>)&#123;&#125;,  <span class="hljs-comment">// 创建数据</span><br>    <span class="hljs-title function_">delete</span>(<span class="hljs-params"></span>)&#123;&#125;,  <span class="hljs-comment">// 删除数据</span><br>    <span class="hljs-title function_">update</span>(<span class="hljs-params"></span>)&#123;&#125;,  <span class="hljs-comment">// 更新数据</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>View（视图） 这部分是界面上的展示，展示的是Model中的数据的状态，当数据发送变化，视图也会随之重新渲染页面。</li></ol><p>View示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">View</span> = &#123;<br><span class="hljs-attr">container</span>:&#123;&#125;,  <span class="hljs-comment">// 视图的容器</span><br><span class="hljs-attr">element</span>:&#123;&#125;,    <span class="hljs-comment">// 视图的内容</span><br><span class="hljs-title function_">render</span>(<span class="hljs-params"></span>)&#123;&#125;,    <span class="hljs-comment">// 渲染视图</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>Controller（控制器）这一部分是负责结合数据和视图这两部分，使之能够相互关联起来。控制器的工作流程：从视图中获取事件或者输入，根据业务逻辑让Model对数据进行处理，然后通知视图进行更新。</li></ol><p>Controller示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Controller</span> = &#123;<br>    <span class="hljs-attr">events</span>:&#123;&#125;,      <span class="hljs-comment">// 事件元素</span><br>    <span class="hljs-title function_">bindEvent</span>(<span class="hljs-params"></span>)&#123;&#125;,  <span class="hljs-comment">// 绑定事件监听</span><br>    <span class="hljs-title function_">action1</span>(<span class="hljs-params"></span>)&#123;&#125;,    <span class="hljs-comment">// 事件触发回调函数（某些业务逻辑）</span><br>    <span class="hljs-title function_">action2</span>(<span class="hljs-params"></span>)&#123;&#125;,    <span class="hljs-comment">// 事件触发回调函数（某些业务逻辑）</span><br>    <span class="hljs-title function_">action3</span>(<span class="hljs-params"></span>)&#123;&#125;     <span class="hljs-comment">// 事件触发回调函数（某些业务逻辑）</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="表驱动编程"><a href="#表驱动编程" class="headerlink" title="表驱动编程"></a>表驱动编程</h2><p>表驱动编程中的表指的是通过数据结构哈希表来进行挑选，然后执行相应语句，而不是使用许多逻辑语句（if-else、switch等）来进行选择执行，并且随着操作的增多，逻辑链的增多，表编程带来的效率提升会更高</p><h3 id="非表编程"><a href="#非表编程" class="headerlink" title="非表编程"></a>非表编程</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">weekday</span>(<span class="hljs-params">day</span>) &#123; <br>    <span class="hljs-keyword">if</span>(day%<span class="hljs-number">7</span>===<span class="hljs-number">0</span>)&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;星期天&#x27;</span>; &#125; <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(day%<span class="hljs-number">7</span>===<span class="hljs-number">1</span>)&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;星期一&#x27;</span>; &#125; <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(day%<span class="hljs-number">7</span>===<span class="hljs-number">2</span>)&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;星期二&#x27;</span>; &#125; <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(day%<span class="hljs-number">7</span>===<span class="hljs-number">3</span>)&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;星期三&#x27;</span>; &#125; <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(day%<span class="hljs-number">7</span>===<span class="hljs-number">4</span>)&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;星期四&#x27;</span>; &#125; <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(day%<span class="hljs-number">7</span>===<span class="hljs-number">5</span>)&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;星期五&#x27;</span>; &#125; <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(day%<span class="hljs-number">7</span>===<span class="hljs-number">6</span>)&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;星期六&#x27;</span>; &#125; <br>&#125; <br></code></pre></td></tr></table></figure><h3 id="表编程"><a href="#表编程" class="headerlink" title="表编程"></a>表编程</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">weekday</span>(<span class="hljs-params">day</span>) &#123; <br>    <span class="hljs-keyword">let</span> week = [<span class="hljs-string">&#x27;星期天&#x27;</span>,<span class="hljs-string">&#x27;星期一&#x27;</span>,<span class="hljs-string">&#x27;星期二&#x27;</span>,<span class="hljs-string">&#x27;星期三&#x27;</span>,<span class="hljs-string">&#x27;星期四&#x27;</span>,<span class="hljs-string">&#x27;星期五&#x27;</span>,<span class="hljs-string">&#x27;星期六&#x27;</span>]<br>    <span class="hljs-keyword">return</span> week[day%<span class="hljs-number">7</span>]<br>&#125; <br></code></pre></td></tr></table></figure><p>从上面的例子可以看出，通过表编程可以简化一些逻辑操作。所以适当的运用表编程能够提升代码的效率。</p>]]></content>
    
    
    
    <tags>
      
      <tag>MVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP基本概念</title>
    <link href="/posts/3f4e513f.html"/>
    <url>/posts/3f4e513f.html</url>
    
    <content type="html"><![CDATA[<h2 id="HTTP简介"><a href="#HTTP简介" class="headerlink" title="HTTP简介"></a>HTTP简介</h2><p>HTTP 协议一般指 HTTP（超文本传输协议）是一种用于分布式、协作式和超媒体信息系统的应用层协议，是因特网上应用最为广泛的一种网络传输协议，所有的 WWW 文件都必须遵守这个标准。HTTP 是为 Web 浏览器与 Web 服务器之间的通信而设计的，但也可以用于其他目的。HTTP 是一个基于 TCP&#x2F;IP 通信协议来传递数据的（HTML 文件、图片文件、查询结果等）。</p><h3 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h3><p>HTTP请求流程：</p><ol><li><p>构建请求</p><p>浏览器构建请求行信息，准备向服务器发送网络请求</p></li><li><p>查找缓存</p><p>在发起请求之前会在缓存中查询是否有要请求的文件，如果有就拦截请求，返回缓存中的资源，没有则请求服务器</p></li><li><p>准备IP地址和端口</p><p>请求的URL一般会经过DNS转换成IP地址，并且还需要获取对应的端口</p></li><li><p>等待TCP队列</p><p>在准备好IP和端口之后并不一定会马上发送，因为同一个域名同时最多可以支持6个TCP连接，所以可能当前请求会进入队列进行排队等待。</p></li><li><p>建立TCP连接</p><p>进行握手建立服务器连接，在开始通信之前要进行连接的建立</p></li><li><p>发送HTTP请求</p><p>连接建立完成之后，发送HTTP请求进行通信</p></li></ol><h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><ul><li><code>请求动词</code>  <code>路径加查询参数</code>  <code>协议名/版本</code>           （请求行）</li><li>Host：域名或IP  端口号                                      （请求头）</li><li>Accept： text&#x2F;html      （希望接受的数据类型）（请求头）</li><li>Content-Type：（发送的实体数据的数据类型）（请求头）</li><li>（请求体）</li></ul><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li><p>三部分：请求行、请求头、请求体</p></li><li><p>请求动词有 GET &#x2F; POST &#x2F; PUT &#x2F; PATCH &#x2F; DELETE 等</p></li><li><p>请求体在GET请求中一般为空</p></li></ul><p><img src="https://alierq.coding.net/p/images/d/images/git/raw/master/hexo/202206132335333.png" alt="HTTP请求图示"></p><h3 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h3><p>HTTP响应流程：</p><ol><li><p>返回请求</p><p>服务员一旦完成请求的处理，就可以返回数据给浏览器</p></li><li><p>断开连接</p><p>服务器向客户端返回响应之后，就关闭TCP连接。</p></li></ol><p class="note note-warning">可以在头部信息中加入`Contention:Keep-Alive`让TCP连接保持连接</p><h4 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h4><ul><li><code>协议名/版本</code>  <code>状态码</code>  <code>状态字符串</code>    （响应行）</li><li>Content-Type：响应体的格式            （响应头）</li><li>（响应体）（下载内容）</li></ul><h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><ul><li><p>三部分：状态行、响应头、响应体</p></li><li><p>常见的<code>状态码</code>是重点</p></li></ul><p><img src="https://alierq.coding.net/p/images/d/images/git/raw/master/hexo/202206132335024.png" alt="HTTP响应图示"></p><h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><p>HTTP状态码能够描述返回的请求结果。借助状态码可以知道服务器是否正确的处理请求</p><h4 id="状态码类别"><a href="#状态码类别" class="headerlink" title="状态码类别"></a>状态码类别</h4><table><thead><tr><th>状态码</th><th>类别</th><th>说明</th></tr></thead><tbody><tr><td><strong>1XX</strong></td><td>Informational（信息性状态码）</td><td>接收的请求正在处理</td></tr><tr><td><strong>2XX</strong></td><td>Success（成功状态码）</td><td>请求正常处理完毕</td></tr><tr><td><strong>3XX</strong></td><td>Redirection（重定向状态码）</td><td>需要进行附加操作以完成请求</td></tr><tr><td><strong>4XX</strong></td><td>Client Error（客户端错误状态码）</td><td>错误来自客户端</td></tr><tr><td><strong>5XX</strong></td><td>Server Error（服务器错误状态码）</td><td>错误来自服务器</td></tr></tbody></table><h4 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h4><p><code>2XX</code>：请求被正确处理</p><table><thead><tr><th>状态码</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td><strong>200 OK</strong></td><td>请求在服务段被正常处理</td><td>GET 方法，对应请求资源的实体会作为响应返回；HEAD 方法，不返回</td></tr><tr><td><strong>204 No Content</strong></td><td>请求正确处理，但是不返回实体的主体</td><td>用于客户端往服务器发送信息，而客户端不用更新</td></tr><tr><td><strong>204 Partial Content</strong></td><td>客户端有请求范围，服务器成功执行范围请求</td><td>响应报文中包含由 Content-Range 指定范围的实体内容</td></tr></tbody></table><p><code>3XX</code>：浏览器需要执行某些特殊的处理来正确处理请求</p><table><thead><tr><th>状态码</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td><strong>301 Moved Permanently</strong></td><td>永久性重定向</td><td>请求的资源已被分配了新的URI，以后应使用新的 URI</td></tr><tr><td><strong>302 Found</strong></td><td>临时性重定向</td><td>请求的资源已被分配了新的 URI，本次应使用新的 URI</td></tr><tr><td><strong>303 See Other</strong></td><td>临时性重定向</td><td>与302有相同的功能，但本次应使用 GET 方法定向获取请求的资源</td></tr><tr><td><strong>304 Not Modified</strong></td><td>发送附带请求的请求，资源不满足条件</td><td>附带条件：GET 方法的请求报文中包含 If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since 中任一首部</td></tr><tr><td><strong>307 Temporary Redirect</strong></td><td>临时性重定向</td><td>与302有相同的功能，但307 会遵照浏览器标准，请求方法不会从 POST 变成 GET</td></tr></tbody></table><p><code>4XX</code>：客户端时发送错误的原因所在</p><table><thead><tr><th>状态码</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td><strong>400 Bad Request</strong></td><td>请求报文中存在语法错误</td><td>错误发生时，需修改请求的内容后再次发送请求</td></tr><tr><td><strong>401 Unauthorized</strong></td><td>请求需要通过HTTP 认证</td><td>浏览器初次接收到 401 响应，会弹出认证用的对话窗口；之前已进行过 1 次请求，则表示用 户认证失败</td></tr><tr><td><strong>403 Forbidden</strong></td><td>服务器拒绝请求</td><td>服务器端没有必要给出拒绝的详细理由，想说明可以在实体的主体部分描述原因；未授权的访问可能导致403</td></tr><tr><td><strong>404 Not Found</strong></td><td>服务器上无法找到请求的资源</td><td>可以在服务器端拒绝请求且不想说明理由时使用</td></tr></tbody></table><p><code>5XX</code>：服务器本身发送错误</p><table><thead><tr><th>状态码</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td><strong>500 Internal Server Error</strong></td><td>服务器执行请求时出错</td><td></td></tr><tr><td><strong>503 Service Unavailable</strong></td><td>服务器无法处理请求</td><td>服务器暂时处于超负载或正在进行停机维护</td></tr></tbody></table><p>更多状态码可以访问<a href="https://http.cat/">HTTP Cat</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JSON简述</title>
    <link href="/posts/e38660dc.html"/>
    <url>/posts/e38660dc.html</url>
    
    <content type="html"><![CDATA[<h2 id="JSON简介"><a href="#JSON简介" class="headerlink" title="JSON简介"></a>JSON简介</h2><p>JSON是一门独立的标记语言，用来展示数据，它易于人阅读和编写。同时也易于机器解析和生成。</p><h2 id="JSON支持数据类型"><a href="#JSON支持数据类型" class="headerlink" title="JSON支持数据类型"></a>JSON支持数据类型</h2><ul><li>string - 只支持双引号，不支持单引号和无引号</li><li>number - 支持科学计数法</li><li>bool - true和false</li><li>null - 没有undefined</li><li>object </li><li>array</li></ul><h2 id="JSON数据的转换"><a href="#JSON数据的转换" class="headerlink" title="JSON数据的转换"></a>JSON数据的转换</h2><h3 id="JSON-parse（反序列化）"><a href="#JSON-parse（反序列化）" class="headerlink" title="JSON.parse（反序列化）"></a>JSON.parse（反序列化）</h3><p>将符合JSON语法的字符串转成JS对应类型的数据</p><p>注意：</p><ul><li>由于JSON只有六种语法，所以转成的数据也只有6种</li><li>不符合JSON语法，则直接抛出一个Error对象</li><li>一般使用try catch捕获错误</li></ul><h3 id="JSON-stringify（序列化）"><a href="#JSON-stringify（序列化）" class="headerlink" title="JSON.stringify（序列化）"></a>JSON.stringify（序列化）</h3><p>是JSON.parse的逆运算用于将符合JSON语法的数据类型转成JSON格式</p><p>注意</p><ul><li>因为JS数据类型比JSON多，所以转换不一定都能成功，如果失败就抛出Error对象</li></ul><p><a href="http://json.org/json-zh.html">JSON中文介绍官网</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>JSON</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git入门</title>
    <link href="/posts/8e7db504.html"/>
    <url>/posts/8e7db504.html</url>
    
    <content type="html"><![CDATA[<h2 id="Git指令"><a href="#Git指令" class="headerlink" title="Git指令"></a>Git指令</h2><h3 id="设置Git配置"><a href="#设置Git配置" class="headerlink" title="设置Git配置"></a>设置Git配置</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">git config --global user.name 你的英文名<br>git config --global user.email 你的邮箱<br>git config --global push.default simple<br>git config --global core.quotepath <span class="hljs-literal">false</span><br>git config --global core.editor <span class="hljs-string">&quot;code --wait&quot;</span><br>git config --global core.autocrlf input<br></code></pre></td></tr></table></figure><h3 id="查看Git配置"><a href="#查看Git配置" class="headerlink" title="查看Git配置"></a>查看Git配置</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git config --global --list<br></code></pre></td></tr></table></figure><h3 id="常用Git指令"><a href="#常用Git指令" class="headerlink" title="常用Git指令"></a>常用Git指令</h3><p><code>git init</code> ：初始化一个git仓库</p><p><code>git add 文件名\路径</code>：提交文件到暂存区</p><p><code>git commit -m &quot;提交信息内容&quot;</code> ：将文件提交到仓库中，并注上提交信息</p><p><code>git commit -v</code>：能够在编辑器中看到自己当前的修改行数内容</p><p><code>git commit -v --amend</code> ：VScode终端提交语句</p><p><code>git log</code> ：查看提交记录</p><p><code>git reflog</code>：查看历史记录（包括回退的记录）</p><p><code>git reset --hard 版本号前6位</code>：回退到指定版本</p><p><code>git branch </code>：查看所有分支，以及当前所在分支</p><p><code>git branch 分支名</code>：创建一个新分支</p><p><code>git checkout 分支名</code>：切换到指定分支</p><p><code>git merge 分支名</code>：将另一个分支合并到当前分支</p><p><code>git status -sb</code>：用来查看当前哪个文件冲突了</p><p><code>git branch -d 分支名</code>：删除合并后的无用的分支</p><p><code>git remote -v</code>：显示所有远程仓库</p><p class="note note-warning">当合并分支的时候可能会产生冲突，解决完冲突之后应重新add、commit该文件（此时commit时不带参数）</p><p><span style="color:red;"><code>.gitignore文件</code>：配置哪些文件不需要提交</span></p><p>常见不用提交目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">node_modules<br>.DS_Store<br>.idea<br>.vscode<br></code></pre></td></tr></table></figure><h3 id="远程git仓库"><a href="#远程git仓库" class="headerlink" title="远程git仓库"></a>远程git仓库</h3><h4 id="创建ssh-key"><a href="#创建ssh-key" class="headerlink" title="创建ssh key"></a>创建ssh key</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen -t rsa -b 4096 -C &quot;你的任意邮箱地址&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">-t 表示密钥的类型 ，-b表示密钥的长度，-C 用于识别这个密钥的注释</span><br></code></pre></td></tr></table></figure><h4 id="Github配置公钥"><a href="#Github配置公钥" class="headerlink" title="Github配置公钥"></a>Github配置公钥</h4><p><img src="https://alierq.coding.net/p/images/d/images/git/raw/master/hexo/202206132145247.png" alt="git设置公钥"></p><h4 id="测试Github连接"><a href="#测试Github连接" class="headerlink" title="测试Github连接"></a>测试Github连接</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh -T git@github.com<br></code></pre></td></tr></table></figure><h4 id="上传远程仓库"><a href="#上传远程仓库" class="headerlink" title="上传远程仓库"></a>上传远程仓库</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">将本地仓库和远程仓库连接起来</span><br>git remote add origin git@github.com:AlierQ/GitTest.git<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将原有的master改名位main,因为github上的主分支名称由master改为了main</span><br>git branch -M main<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">推到远程仓库的main分支</span><br>git push -u origin main<br></code></pre></td></tr></table></figure><h4 id="上传其他分支"><a href="#上传其他分支" class="headerlink" title="上传其他分支"></a>上传其他分支</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">方式1</span><br>git checkout 分支名<br>git push -u origin 分支名<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">方式2</span><br>git push origin 本地分支名:远程分支名<br></code></pre></td></tr></table></figure><h4 id="获取远程合并本地"><a href="#获取远程合并本地" class="headerlink" title="获取远程合并本地"></a>获取远程合并本地</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">将远程的仓库合并到本地</span><br>git pull<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">若有多个仓库名</span><br>git pull 仓库名 远程分支名:本地分支名<br></code></pre></td></tr></table></figure><h4 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">从目标地址克隆项目到本地</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">当前目录下新建一个与项目同名的文件夹，将项目放在里面</span><br>git clone git@XXXXXX[目标地址]    <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">新建一个abc目录，将克隆的项目放在这里</span><br>git clone git@XXXXXX[目标地址] abc <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在当前目录下直接存放项目,(最好是空文件夹)</span><br>git clone git@XXXXXX[目标地址] .<br></code></pre></td></tr></table></figure><h3 id="Git高级操作"><a href="#Git高级操作" class="headerlink" title="Git高级操作"></a>Git高级操作</h3><h4 id="bash-alias简化命令"><a href="#bash-alias简化命令" class="headerlink" title="bash alias简化命令"></a>bash alias简化命令</h4><p>1、向&#x2F;.bashrc文件里面写入配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">touch ~/.bashrc<br>echo &#x27;alias ga=&quot;git add&quot;&#x27;&gt;&gt; ~/.bashrc<br>echo &#x27;alias gc=&quot;git commit -v&quot;&#x27;&gt;&gt; ~/.bashrc<br>echo &#x27;alias gl=&quot;git pull&quot;&#x27;&gt;&gt; ~/.bashrc<br>echo &#x27;alias gp=&quot;git push&quot;&#x27;&gt;&gt; ~/.bashrc<br>echo &#x27;alias gco=&quot;git checkout&quot;&#x27;&gt;&gt; ~/.bashrc<br>echo &#x27;alias gst=&quot;git status -sb&quot;&#x27;&gt;&gt; ~/.bashrc<br></code></pre></td></tr></table></figure><p>2、加载配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">source ~/.bashrc<br></code></pre></td></tr></table></figure><h4 id="美化提交历史记录"><a href="#美化提交历史记录" class="headerlink" title="美化提交历史记录"></a>美化提交历史记录</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git rebase -i 版本号<br></code></pre></td></tr></table></figure><p><img src="https://alierq.coding.net/p/images/d/images/git/raw/master/hexo/202206132145993.png"></p><h4 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h4><h5 id="中止"><a href="#中止" class="headerlink" title="中止"></a>中止</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git rebase --abort<br></code></pre></td></tr></table></figure><h5 id="继续"><a href="#继续" class="headerlink" title="继续"></a>继续</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git rebase --continue<br></code></pre></td></tr></table></figure><h4 id="临时隐藏文件"><a href="#临时隐藏文件" class="headerlink" title="临时隐藏文件"></a>临时隐藏文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">git add后可以使用该命令将文件隐藏</span><br>git stash<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">取消隐藏</span><br>git stash pop<br></code></pre></td></tr></table></figure><p class="note note-warning">可以连续使用，pop顺序与放入顺序相反</p><h3 id="忽略文件-gitignore"><a href="#忽略文件-gitignore" class="headerlink" title="忽略文件.gitignore"></a>忽略文件.gitignore</h3><p>.gitinore可以配置哪些文件不需要提交</p><p>文件编写规则：</p><ol><li>忽略文件中的空行或以井号（#）开始的行将会被忽略。（注释）</li><li>可以使用Linux通配符。例如：星号（*）代表任意多个字符，问号（?）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1,string2,…}）代表可选的字符串等。</li><li>如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。</li><li>如果名称的最前面是一个路径分隔符（&#x2F;），表示要忽略的文件在此目录下，而子目录中的文件不忽略。</li><li>如果名称的最后面是一个路径分隔符（&#x2F;），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。</li></ol><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">注释</span><br><br>*.txt        # 忽略所有 .txt结尾的文件,这样的话上传就不会被选中！<br><br>!lib.txt     # 但lib.txt除外<br><br>/temp        # 仅忽略项目根目录下的temp文件,不包括其它目录subdir/temp<br><br>build/       # 忽略build/目录下的所有文件<br><br>doc/*.txt    # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器客户端存储</title>
    <link href="/posts/b7f743a4.html"/>
    <url>/posts/b7f743a4.html</url>
    
    <content type="html"><![CDATA[<h2 id="客户端存储"><a href="#客户端存储" class="headerlink" title="客户端存储"></a>客户端存储</h2><p>有时候我们会希望能够将服务器的一些特殊的用户数据存贮在本地，这个时候就需要用到客户端数据存储技术</p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>Cookie是服务器下发给浏览器的一段字符串，以键值对的形式存储</p><h4 id="Cookie的使用"><a href="#Cookie的使用" class="headerlink" title="Cookie的使用"></a>Cookie的使用</h4><p>客户端：</p><ul><li>写入Cookie</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span>=<span class="hljs-string">&quot;key=value;expires=失效时间&quot;</span><br></code></pre></td></tr></table></figure><p class="note note-warning">如果未指定expires，浏览器关闭时cookie就失效</p><ul><li>读取Cookie</li></ul><p>通过<code>document.cookie</code>进行整体读取，然后再根据<code>;</code>和<code>=</code>进行分割</p><p>服务器端：</p><ul><li>通过Set-Cookie在响应头设置Cookie</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">response.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Set-Cookie&#x27;</span>,<span class="hljs-string">`session_id=111; HttpOnly`</span>);<br></code></pre></td></tr></table></figure><p>更多操作见<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Set-Cookie">Set-Cookie MDN文档</a></p><h4 id="Cookie优缺点"><a href="#Cookie优缺点" class="headerlink" title="Cookie优缺点"></a>Cookie优缺点</h4><p>Cookie的优点：</p><ul><li>能够和服务器端交互</li><li>浏览器自动管理不同站点的数据，并且能够之后的发起相同二级域名请求中附上cookie</li></ul><p>Cooke的缺点：</p><ul><li>安全性差</li><li>数据量受限（4KB）</li><li>可用性受限</li><li>明文存储</li></ul><h4 id="防止用户篡改cookie"><a href="#防止用户篡改cookie" class="headerlink" title="防止用户篡改cookie"></a>防止用户篡改cookie</h4><p>思路一：</p><p>将Cookie进行加密之后再发送给前端，后端读取Cookie解密后再使用但是这种方法有漏洞，加密后的内容可以无限期使用</p><p>解决方法：JWT</p><p>思路二：</p><p>将用户信息放在服务器的文件中，给用户信息碎甲产生一个id，然后将这个id发给前端，后端去文件中读取id对应的用户内容。</p><h3 id="WebStorage"><a href="#WebStorage" class="headerlink" title="WebStorage"></a>WebStorage</h3><p>WebStorage是HTML5中引入的本地存储解决方案，可以在客户端本地存储数据<br>由两部分组成：</p><ul><li>localStorage：在本地永久性存储数据</li><li>sessionStorage：存储的数据只会在会话期间有效，关闭浏览器则自动删除</li></ul><h4 id="WebStorage的使用"><a href="#WebStorage的使用" class="headerlink" title="WebStorage的使用"></a>WebStorage的使用</h4><p>localStorage和sessionStorage的用法相同，常用API如下：</p><table><thead><tr><th>方法&#x2F;属性</th><th>作用</th></tr></thead><tbody><tr><td><strong>setItem(key,value)</strong></td><td>写入数据，添加&#x2F;修改键值对</td></tr><tr><td><strong>getItem(key)</strong></td><td>读取数据，根据键读取对应的值，不存在返回空</td></tr><tr><td><strong>removeItem(key)</strong></td><td>删除数据，根据键删除对应的键值对</td></tr><tr><td><strong>key(index)</strong></td><td>根据索引获取对应的键</td></tr><tr><td><strong>clear()</strong></td><td>清空数据</td></tr><tr><td><strong>length</strong></td><td>获取键值对数量</td></tr></tbody></table><p class="note note-warning">WebStorage中只能够存储字符串数据，如果要存储对象，则要通过JSON.stringify()序列化然后进行存储</p><h4 id="WebStorage的事件监听"><a href="#WebStorage的事件监听" class="headerlink" title="WebStorage的事件监听"></a>WebStorage的事件监听</h4><p>可以对WebStorage进行事件监听，当数据发生变化的时候执行回调函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;storage&#x27;</span>,<span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-comment">// 函数体</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>StorageEvent事件对象参数：</p><ul><li>key  发送变化的健名</li><li>oldValue  变化之前的值</li><li>newValue  变化之后的值</li><li>storageArea  发送变化的是localStorage还是sessionStorage</li><li>url  引发变化的页面对应的url</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Cookie</tag>
      
      <tag>WebStorage</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅析跨域问题</title>
    <link href="/posts/721439c2.html"/>
    <url>/posts/721439c2.html</url>
    
    <content type="html"><![CDATA[<h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><h3 id="源的概念"><a href="#源的概念" class="headerlink" title="源的概念"></a>源的概念</h3><p>window.origin或location.origin就可以得到当前源</p><p>源 &#x3D; 协议 + 域名 + 端口号</p><h3 id="同源的概念"><a href="#同源的概念" class="headerlink" title="同源的概念"></a>同源的概念</h3><p>如果两个url的协议、域名、端口号都完全一致，则这两个url就是同源的</p><p>例如：</p><p><a href="https://qq/.com">https://qq/.com</a> 和 <a href="https://www.baidu.com/">https://www.baidu.com</a> 不同源</p><p><a href="https://baidu.com/">https://baidu.com</a> 和 <a href="https://www.baidu.com/">https://www.baidu.com</a> 不同源</p><p>注意：只有完全一致才能算是同源</p><h3 id="同源策源的概念"><a href="#同源策源的概念" class="headerlink" title="同源策源的概念"></a>同源策源的概念</h3><p>浏览器如果JavaScript运行在源A中就只允许获取源A的数据，而不能够源B中的数据，即不允许跨域</p><p>同源策略的目的为了保护用户的隐私</p><h2 id="跨域请求示例"><a href="#跨域请求示例" class="headerlink" title="跨域请求示例"></a>跨域请求示例</h2><p>我现在在本地9999端口的网页发送一个请求去请求本地8888端口的资源，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> request = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br><br>request.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;get&#x27;</span>,<span class="hljs-string">&#x27;http://localhost:8888/friends.json&#x27;</span>)<br><br>request.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-function">()=&gt;</span>&#123;<br>  <span class="hljs-keyword">if</span>(request.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span> &amp;&amp; request.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>)&#123;<br>    <span class="hljs-keyword">let</span> ul = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;ul&#x27;</span>);<br>    <span class="hljs-keyword">let</span> friends = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(request.<span class="hljs-property">response</span>);<br>    friends.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>)=&gt;</span>&#123;<br>        <span class="hljs-keyword">let</span> li = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;li&#x27;</span>);<br>        li.<span class="hljs-property">textContent</span> = item.<span class="hljs-property">name</span>;<br>        ul.<span class="hljs-title function_">appendChild</span>(li);<br>    &#125;)<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(ul);<br>  &#125;<br>&#125;<br><br>request.<span class="hljs-title function_">send</span>();<br></code></pre></td></tr></table></figure><p>浏览器就会发出下面的错误信息，提示你进行了跨域请求并且已经被浏览器进行阻止。</p><p><img src="https://alierq.coding.net/p/images/d/images/git/raw/master/hexo/202206110109578.png" alt="浏览器提示跨域错误"></p><h2 id="跨域解决方式"><a href="#跨域解决方式" class="headerlink" title="跨域解决方式"></a>跨域解决方式</h2><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>CORS（Cross-Origin Resource Sharing）跨域资源共享，是一种基于 HTTP 头的机制，该机制通过允许服务器标示除了它自己以外的其它origin（域、协议和端口），这样其他网站可以直接请求该网站的这些资源。</p><p>使用方法：</p><p>在被请求网站的响应头中进行添加</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">...<br>Access-Control-Allow-Origin: http:<span class="hljs-regexp">//</span>xxx.xxxx.xxx    <span class="hljs-regexp">//</span>指定网址访问<br><br>or<br><br>Access-Control-Allow-Origin: *   <span class="hljs-regexp">//</span> 所有均可访问<br>...<br></code></pre></td></tr></table></figure><p>更多请见-&gt;<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82">MDN CORS文档</a></p><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>JSONP是当浏览器不支持CORS（比如IE浏览器）时使用的一种跨域方式</p><h5 id="JSONP的实现"><a href="#JSONP的实现" class="headerlink" title="JSONP的实现"></a>JSONP的实现</h5><p>在请求网站中引入被请求网站的js代码，代码中cd是指定的回调函数</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://localhost:8888/jsonp/friends.js?callback=callback&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>后台内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span>(path === <span class="hljs-string">&#x27;/jsonp/friends.js&#x27;</span>)&#123;<br>    response.<span class="hljs-property">statusCode</span> = <span class="hljs-number">200</span><br>    response.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;text/javascript;charset=utf-8&#x27;</span>)<br>    <span class="hljs-keyword">const</span> string = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&#x27;public/friends.json&#x27;</span>)<br>    <br>    <span class="hljs-comment">// query.cd 获取前端传过来的cd参数的值</span><br>    <span class="hljs-comment">// 将cd的值作为回调函数的名称，进行拼接然后返回</span><br>    response.<span class="hljs-title function_">write</span>(query.<span class="hljs-property">callback</span> + <span class="hljs-string">&#x27;(&#x27;</span> + string + <span class="hljs-string">&#x27;)&#x27;</span>)<br>    response.<span class="hljs-title function_">end</span>()<br> &#125;<br></code></pre></td></tr></table></figure><p>后台处理之后&#x2F;jsonp&#x2F;friends.js下的js文件的内容就变成了下面这样，变成了调用这个callback的函数，并且将数据作为参数传入callback中。</p><p><img src="https://alierq.coding.net/p/images/d/images/git/raw/master/hexo/202206110109038.png" alt="friends.js内容"></p><p>callback函数的定义如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">callback</span>(<span class="hljs-params">data</span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>&#125;<br></code></pre></td></tr></table></figure><p>控制台输出如下</p><p><img src="https://alierq.coding.net/p/images/d/images/git/raw/master/hexo/202206110109369.png" alt="控制台输出"></p><p>至此，就已经能够在本页面访问到目标页面的数据了。</p><p>注意：JSONP的实现需要后端支持</p><p>上面的做法有一个缺点，这样设置JSONP之后所有网站都能够拿到这些数据了，如果不想所有网站都能够拿到数据，</p><p>这个时候我们需要做出一些限制：</p><ol><li>使用请求头里面的referer进行匹配</li><li>待补充…</li></ol><h4 id="JSONP优化"><a href="#JSONP优化" class="headerlink" title="JSONP优化"></a>JSONP优化</h4><ol><li><p>自定义回调函数名 （上面的示例已经实现）</p></li><li><p>动态添加删除script标签</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>)<br>script.<span class="hljs-property">src</span> = <span class="hljs-string">`http://localhost:8888/jsonp/friends.js?callback=callback`</span><br>script.<span class="hljs-property">onload</span> = <span class="hljs-function">()=&gt;</span>&#123;<br>script.<span class="hljs-title function_">remove</span>()<br>&#125;<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(script)<br></code></pre></td></tr></table></figure><h4 id="JSONP优缺点"><a href="#JSONP优缺点" class="headerlink" title="JSONP优缺点"></a>JSONP优缺点</h4><p>优点：</p><ul><li>能够在IE下实现跨域</li></ul><p>缺点：</p><ul><li>只能得到失败还是成功，无法得到状态码以及响应头等</li><li>无法使用post请求，因为script只支持post</li></ul><h4 id="Promise规范封装JSONP"><a href="#Promise规范封装JSONP" class="headerlink" title="Promise规范封装JSONP"></a>Promise规范封装JSONP</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 封装jsonp</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">jsonp</span>(<span class="hljs-params">url</span>)&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,rejected</span>)=&gt;</span>&#123;<br>    <span class="hljs-comment">// 随机生成回调函数名</span><br><span class="hljs-keyword">const</span> random = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>();<br>    <span class="hljs-comment">// 回调函数</span><br>    <span class="hljs-variable language_">window</span>[random] = <span class="hljs-function">(<span class="hljs-params">data</span>)=&gt;</span>&#123;<br>      <span class="hljs-title function_">resolve</span>(data);<br>    &#125;<br>    <span class="hljs-keyword">const</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>)<br>    script.<span class="hljs-property">src</span> = url + <span class="hljs-string">`?callback=`</span> + random;<br>    script.<span class="hljs-property">onload</span> = <span class="hljs-function">()=&gt;</span>&#123;<br>      script.<span class="hljs-title function_">remove</span>()<br>    &#125;<br>    script.<span class="hljs-property">onerror</span> = <span class="hljs-function">()=&gt;</span>&#123;<br>      <span class="hljs-title function_">rejected</span>();<br>    &#125;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(script)<br>  &#125;)<br>&#125;<br><br><span class="hljs-comment">// 调用jsonp</span><br><span class="hljs-title function_">jsonp</span>(<span class="hljs-string">&#x27;http://localhost:8888/jsonp/friends.js&#x27;</span>)<br>.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>)=&gt;</span>&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>&#125;,<span class="hljs-function">()=&gt;</span>&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;请求失败！&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><p>注意：这种方式封装JSONP需要将回调函数放在window上，否则因为作用域的原因会使得friends.js中的回调函数无法访问到。另外，如果只有一个jsonp请求，可以使用一个回调函数，但是一旦出现了多个jsonp请求，就要使用不同的回调函数了，上面采用了随机数的方式生成回调函数名。</p><h2 id="跨域常见问题"><a href="#跨域常见问题" class="headerlink" title="跨域常见问题"></a>跨域常见问题</h2><h4 id="为什么可以使用其他网站上的css、js、和img？"><a href="#为什么可以使用其他网站上的css、js、和img？" class="headerlink" title="为什么可以使用其他网站上的css、js、和img？"></a>为什么可以使用其他网站上的css、js、和img？</h4><p>同源策略限制的是数据访问，在网站中使用js、css、img时是属于引用，不能够获取到其中数据的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>CORS</tag>
      
      <tag>JSONP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅述Promise</title>
    <link href="/posts/47308023.html"/>
    <url>/posts/47308023.html</url>
    
    <content type="html"><![CDATA[<p><img src="https://alierq.coding.net/p/images/d/images/git/raw/master/hexo/202206092334626.png"></p><h2 id="Promise简介"><a href="#Promise简介" class="headerlink" title="Promise简介"></a>Promise简介</h2><p>Promise是前端解决异步任务的统一方式。<br>从JavaScript的语法上而言：Promise是一个对象，可以从它身上获取异步操作的消息。<br>从Promise的词意上而言：Promise的意思是“承诺”，它承诺过一段时间给你异步任务操作的结果。</p><h2 id="Promise状态"><a href="#Promise状态" class="headerlink" title="Promise状态"></a>Promise状态</h2><ul><li>pending（等待状态）</li><li>fulfiled（成功状态）</li><li>rejected（失败状态）</li></ul><h2 id="Promise特点"><a href="#Promise特点" class="headerlink" title="Promise特点"></a>Promise特点</h2><ol><li><p>对象的状态不会受外界的影响，只有异步操作的结果可以决定当前是哪一种状态，其他的操作无法改变这个状态。</p></li><li><p>一旦状态改变，之后就不会再改变了，任何时候都能够得到这个结果。Promise中的对象状态的改变，只有两种可能：<span class="label label-info">（pending——&gt;&gt;fulfiled）</span>、<span class="label label-info">（pending——&gt;&gt;rejected）</span>一旦这种情况发生了，状态就固定了，不会再改变。</p></li><li><p>创建了Promise对象之后就会立即执行</p></li></ol><p class="note note-warning">如果你在状态改变之后给Promise对象添加回调函数，你仍然能够得到这个结果。但如果是事件，你一旦错过了这个事件的触发，你再进行监听就无法得到之前的结果了。</p><h2 id="Promise使用"><a href="#Promise使用" class="headerlink" title="Promise使用"></a>Promise使用</h2><h3 id="创建Promise对象"><a href="#创建Promise对象" class="headerlink" title="创建Promise对象"></a>创建Promise对象</h3><p>我们可以通过<span class="label label-info">new</span>关键字创建一个Promise对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>)&#123;<br><span class="hljs-comment">// 异步操作</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;执行了一些异步操作&#x27;</span>);<br><span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;拿到的一些数据&#x27;</span>);<br>&#125;,<span class="hljs-number">2000</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://alierq.coding.net/p/images/d/images/git/raw/master/hexo/202206100019947.png"></p><p>从上面的执行结果我们就可以看出Promise对象在一创建出来就被立即执行了，所以在使用Promise对象的时候通常会使用一个函数将他包裹起来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">async</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>)&#123;<br>        <span class="hljs-comment">// 异步操作</span><br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;执行了一些异步操作&#x27;</span>);<br>            <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;拿到的一些数据&#x27;</span>);<br>        &#125;,<span class="hljs-number">2000</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用函数包裹并return对象之后，我们在调用async这个函数的时候就会得到一个Promise对象，我们就可以使用Promise对象自身及其原型上的方法了，例如：</p><p><span class="label label-info">.resolve()</span>、<span class="label label-info">.reject()</span>、<span class="label label-info">.all()</span>、<span class="label label-info">.race()</span>、<span class="label label-info">.then()</span>、<span class="label label-info">.catch()</span></p><p>未完待续…</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Promise</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript原生AJAX</title>
    <link href="/posts/d0443184.html"/>
    <url>/posts/d0443184.html</url>
    
    <content type="html"><![CDATA[<h2 id="AJAX请求的步骤"><a href="#AJAX请求的步骤" class="headerlink" title="AJAX请求的步骤"></a>AJAX请求的步骤</h2><ol><li>创建XMLHttpRequest对象</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> request = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br></code></pre></td></tr></table></figure><ol start="2"><li>调用XMLHttpRequest对象建立连接</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">request.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;get&#x27;</span>,<span class="hljs-string">&#x27;/index.html&#x27;</span>)<br></code></pre></td></tr></table></figure><ol start="3"><li><p>监听对象</p><ul><li>使用onload或者onerror监听</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">request.<span class="hljs-property">onload</span> = <span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(request.<span class="hljs-property">response</span>)  <span class="hljs-comment">// 可以获取请求到的内容</span><br>&#125;<br><br>request.<span class="hljs-property">onerror</span> = <span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;请求错误！&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用onreadystatechange监听</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">request.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-function">()=&gt;</span>&#123;<br>request.<span class="hljs-property">readyState</span> <span class="hljs-comment">// 获取当前XMLHttpRequest对象的状态</span><br>    <br>    request.<span class="hljs-property">status</span> <span class="hljs-comment">// 获取当前请求的状态码</span><br>    <br>    <span class="hljs-comment">// 根据当前request对象的状态和请求的状态码进行相应的处理</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>调用XMLHttpRequest对象的send()方法发送请求</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">request.<span class="hljs-title function_">send</span>() <br></code></pre></td></tr></table></figure><h2 id="readyState状态"><a href="#readyState状态" class="headerlink" title="readyState状态"></a>readyState状态</h2><p><strong>XMLHttpRequest.readyState</strong>属性返回的是一个XMLHttpRequest 代理当前所处的状态</p><table><thead><tr><th>值</th><th>状态</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>UNSENT</td><td>代理被创建，但未调用open()方法</td></tr><tr><td>1</td><td>OPENED</td><td>open()方法已经被调用</td></tr><tr><td>2</td><td>HEADERS_RECEIVED</td><td>send()方法已经被调用，并且头部状态已经可以获取</td></tr><tr><td>3</td><td>LOADING</td><td>下载中，responseText属性已经包含部分数据</td></tr><tr><td>4</td><td>DONE</td><td>下载操作已经完成</td></tr></tbody></table><p class="note note-warning">通常在的下载完成之后时候使用onreadystatechange方法</p><h2 id="AJAX请求的数据类型及使用方法"><a href="#AJAX请求的数据类型及使用方法" class="headerlink" title="AJAX请求的数据类型及使用方法"></a>AJAX请求的数据类型及使用方法</h2><ul><li>CSS：得到之后可以将其放入style标签中</li><li>HTML：得到之后使用innerHTML和DOM API加入网页中</li><li>JS：得到之后可以将其放入script标签中</li><li>XML：得到之后使用responseXML和DOM API获取其中的内容</li><li>JSON：得到之后可以使用JSON.parse()将其转化成相应的数据类型</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>AJAX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript同步和异步</title>
    <link href="/posts/95105818.html"/>
    <url>/posts/95105818.html</url>
    
    <content type="html"><![CDATA[<h2 id="JavaScript是单线程"><a href="#JavaScript是单线程" class="headerlink" title="JavaScript是单线程"></a>JavaScript是单线程</h2><p>JavaScript在诞生之初是被用作实现用户和浏览器的一些简单的交互，这也就使得了JavaScript在设计的时候就没有考虑他要做一些很复杂的操作，所以JavaScript就被设计成了单线程的一门语言。并在至今为止他都是一门单线程的脚本语言。</p><p>所谓的单线程是指JavaScript引擎解释和执行的线程只有一个</p><h2 id="同步和异步的概念"><a href="#同步和异步的概念" class="headerlink" title="同步和异步的概念"></a>同步和异步的概念</h2><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>同步的概念：假设我现在手头有两件事要做：切菜和炒菜，我做这两件事情的时候，我必须要先切菜再炒菜，并且一定要等切菜这个任务完成之后才可以开始我炒菜的任务，如果切菜没有完成我就需要一直等待。</p><ul><li>换成计算机的表达：我需要等A事件执行完了，才能去执行B事件，如果A事件没有执行完，我就一直等待，直到它完成，我再去执行B事件。</li></ul><p><span class="label label-info">概括</span>：我一定要拿到结果，拿不到我就不走！</p><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>异步的概念：同样的，现在我的手头也有两件事要做：煲饭和炒菜，我做这两件事情的时候，我可以把饭煲上，然后我就去炒菜，我并不需要等待饭煲好了，再去炒菜，什么时候饭煲好了它可以响一下提醒我。</p><ul><li>换成计算机得表达：我让A事件执行，并且让它做完了之后就提醒我，在他执行的时候我去执行B事件。</li></ul><p><span class="label label-info">概括</span>：我不一定要拿到结果，我继续走，有结果了通知我一声就行！</p><h2 id="JavaScript为什么需要异步任务"><a href="#JavaScript为什么需要异步任务" class="headerlink" title="JavaScript为什么需要异步任务"></a>JavaScript为什么需要异步任务</h2><p>因为JavaScript是单线程的，所以如果现在JavaScript中的一些事件需要长时间的执行，这就会导致后续要执行的事件要进行长时间的等待，极端条件下这种等待是不可控的。所以这个时候就需要引入异步的操作，将这类需要长时间的事件，放到一边去执行，不影响后续的事件。然后在特定的时间或者特定的状态使用一下<span class="label label-info">特殊的手段</span>再去得到之前那些长时间执行的事件的结果。</p><h2 id="如何得到异步任务的结果"><a href="#如何得到异步任务的结果" class="headerlink" title="如何得到异步任务的结果"></a>如何得到异步任务的结果</h2><h3 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h3><p>每隔一段时间就询问一下异步任务是否有结果</p><h3 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h3><p>当异步任务达到某种状态（完成、错误、超时…..）执行一段代码，由这段代码（回调函数）来得到结果。</p><h2 id="常见的异步"><a href="#常见的异步" class="headerlink" title="常见的异步"></a>常见的异步</h2><ul><li>AJAX</li><li>addEventListener</li><li>setTimeout()</li><li>待补充…</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS盒模型</title>
    <link href="/posts/94a1bb4e.html"/>
    <url>/posts/94a1bb4e.html</url>
    
    <content type="html"><![CDATA[<h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><p><img src="https://alierq.coding.net/p/images/d/images/git/raw/master/hexo/202206062244801.png" alt="盒模型示意图"></p><p>如上图所示盒模型由三个部分组成：</p><ul><li>内边距：<span class="label label-info">Padding</span></li><li>边框：<span class="label label-info">Border</span></li><li>外边距：<span class="label label-info">Margin</span></li></ul><h3 id="边框（Border）"><a href="#边框（Border）" class="headerlink" title="边框（Border）"></a>边框（Border）</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 边框宽度 || 边框样式 || 边框颜色 */</span><br><span class="hljs-attribute">border</span>:border-width || border-style || border-color<br></code></pre></td></tr></table></figure><p>边框样式属性值如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">none</span> <span class="hljs-comment">/* 没有边框样式 */</span><br><br>solid <span class="hljs-comment">/* 边框样式为单实线 */</span><br><br>dashed <span class="hljs-comment">/* 边框样式为虚线 */</span><br><br>dotted <span class="hljs-comment">/* 边框样式为点线 */</span><br><br>double <span class="hljs-comment">/* 边框样式为双实线 */</span><br></code></pre></td></tr></table></figure><p>简写形式如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;  <span class="hljs-comment">/* 宽度、颜色、样式 */</span><br></code></pre></td></tr></table></figure><h4 id="特殊边框"><a href="#特殊边框" class="headerlink" title="特殊边框"></a>特殊边框</h4><p>表格边框：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">table</span>&#123;<br><span class="hljs-attribute">border-collapse</span>:collapse;  <span class="hljs-comment">/* 合并表格边框 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>圆角边框：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css">bordre-radius: 左上 右上 右下 左下;<br><span class="hljs-comment">/* 从左上角顺时针分配指 */</span><br><br><span class="hljs-attribute">border-radius</span>:<span class="hljs-number">50%</span><br><span class="hljs-comment">/* 画圆 */</span><br><br>border-radius:<span class="hljs-number">10px</span> <span class="hljs-number">40px</span>;<br><span class="hljs-comment">/* 使用两个值的时候默认第一个设置主对角线，第二个设置副对角线 */</span><br><br><span class="hljs-attribute">border-radius</span>:<span class="hljs-number">10px</span> <span class="hljs-number">20px</span> <span class="hljs-number">30px</span><br><span class="hljs-comment">/* 使用三个值的时候,第一个参数和第三个参数为左上和右下，第二个参数设置副对角线 */</span><br></code></pre></td></tr></table></figure><h3 id="内边距（Padding）"><a href="#内边距（Padding）" class="headerlink" title="内边距（Padding）"></a>内边距（Padding）</h3><p>内容距离边框的距离称为内边距</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">padding-left</span>:<span class="hljs-number">10px</span>;<br><span class="hljs-attribute">padding-right</span>:<span class="hljs-number">20px</span>;<br><span class="hljs-attribute">padding-top</span>:<span class="hljs-number">30px</span>;<br><span class="hljs-attribute">padding-bottom</span>:<span class="hljs-number">40px</span>;<br><span class="hljs-comment">/* 设置上下左右四个方向的内边距 */</span><br></code></pre></td></tr></table></figure><p>简写形式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">padding</span>:<span class="hljs-number">20px</span>;<br><span class="hljs-comment">/* 表示上下左右内边距都是20px的距离 */</span><br><br><span class="hljs-attribute">padding</span>:<span class="hljs-number">20px</span> <span class="hljs-number">30px</span>;<br><span class="hljs-comment">/* 上下是20px 左右是30px的内边距 */</span><br><br><span class="hljs-attribute">padding</span>:<span class="hljs-number">10px</span> <span class="hljs-number">20px</span> <span class="hljs-number">50px</span>;<br><span class="hljs-comment">/* 上内边距时10px 左右内边距是20px 下内边距是50px */</span><br><br><span class="hljs-attribute">padding</span>:<span class="hljs-number">10px</span> <span class="hljs-number">20px</span> <span class="hljs-number">30px</span> <span class="hljs-number">40px</span>;  <br><span class="hljs-comment">/* 顺时针的，上右下左 */</span><br></code></pre></td></tr></table></figure><h3 id="外边距（Margin）"><a href="#外边距（Margin）" class="headerlink" title="外边距（Margin）"></a>外边距（Margin）</h3><p>边框之外到其他元素的距离称为外边</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">margin-top</span>:<span class="hljs-number">10px</span>;<br><span class="hljs-attribute">margin-right</span>:<span class="hljs-number">20px</span>;<br><span class="hljs-attribute">margin-left</span>:<span class="hljs-number">30px</span>;<br><span class="hljs-attribute">margin-bottom</span>:<span class="hljs-number">40px</span>;<br><span class="hljs-comment">/* 分别设置上右下左的外边距 */</span><br><span class="hljs-comment">/* 外边距简写方式与内边距相同 */</span><br></code></pre></td></tr></table></figure><h4 id="外边距实现左右居中"><a href="#外边距实现左右居中" class="headerlink" title="外边距实现左右居中"></a>外边距实现左右居中</h4><p class="note note-warning">使用margin实现盒子水平居中，需要满足以下条件：<br>1、必须block元素<br>2、盒子必须指定width</p>实现方法：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.div</span>&#123;<br><span class="hljs-attribute">width</span>:<span class="hljs-number">960px</span>;<br><span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span> auto; <br><span class="hljs-comment">/* 更推荐下面的写法,不会影响top和bottom的样式 */</span><br><span class="hljs-attribute">margin-left</span>:auto;<br><span class="hljs-attribute">margin-right</span>:auto;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="盒模型分类"><a href="#盒模型分类" class="headerlink" title="盒模型分类"></a>盒模型分类</h3><p>盒模型分为内容盒模型和边框盒模型，如图所示：</p><p><img src="https://alierq.coding.net/p/images/d/images/git/raw/master/hexo/202206062346000.png" alt="内容盒模型和边框盒模型"></p><h4 id="内容盒模型（content-box）"><a href="#内容盒模型（content-box）" class="headerlink" title="内容盒模型（content-box）"></a>内容盒模型（content-box）</h4><p>设置内容盒模型：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">box-sizing</span>:content-box; <span class="hljs-comment">/* 默认是内容盒模型 */</span><br></code></pre></td></tr></table></figure><p>内容盒模型的width只包含了<span class="label label-info">content</span>的内容<br>实际的盒子宽度 &#x3D; <span class="label label-info">width</span> + <span class="label label-info">border</span> + <span class="label label-info">padding</span></p><h4 id="边框盒模型（border-box）"><a href="#边框盒模型（border-box）" class="headerlink" title="边框盒模型（border-box）"></a>边框盒模型（border-box）</h4><p>设置边框盒模型：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">box-sizing</span>:border-box;<br></code></pre></td></tr></table></figure><p>内容盒模型的width包含了<span class="label label-info">content</span>、<span class="label label-info">border</span> 、<span class="label label-info">padding</span>的内容<br>实际的盒子宽度 &#x3D; <span class="label label-info">width</span></p>]]></content>
    
    
    
    <tags>
      
      <tag>Css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS文档流</title>
    <link href="/posts/1ec30961.html"/>
    <url>/posts/1ec30961.html</url>
    
    <content type="html"><![CDATA[<h2 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h2><p>文档流是指HTML页面中的元素排布（流动）的方向</p><h3 id="流动方向"><a href="#流动方向" class="headerlink" title="流动方向"></a>流动方向</h3><ul><li>inline元素：从左到右，到达最右边才会换行</li><li>block元素：从上到下，每一个元素都占据单独的一行</li><li>inline-block元素：从左到右</li></ul><h3 id="宽度"><a href="#宽度" class="headerlink" title="宽度"></a>宽度</h3><ul><li>inline元素：宽度为内部inline元素的和，不能用<span class="label label-info">width</span>指定</li><li>block元素：默认自动计算宽度，可以使用<span class="label label-info">width</span>指定</li><li>inline-block元素：结合两者特点，可以使用<span class="label label-info">width</span>指定</li></ul><p class="note note-warning">TIP：如果元素设置宽度后，文本内容超出，可以通过`word-wrap`设置文本换行</p><h3 id="高度"><a href="#高度" class="headerlink" title="高度"></a>高度</h3><ul><li>inline元素：高度由<span class="label label-info">line-height</span>简介确定，跟<span class="label label-info">height</span>无关</li><li>block元素：高度由内部文档流元素决定，可以设置<span class="label label-info">height</span></li><li>inline-block元素：同上述的block类似，可以设置<span class="label label-info">height</span></li></ul><p class="note note-warning">有以下几点需要注意：</br>    1、不要在inline元素中放block元素</br>    2、不要写width:100%</br>    3、当高度小于内部文档流元素时称为溢出，可使用`overflow`解决</br>    4、block元素没有内容高度为0，inline元素没有内容高度也不为0</p><h3 id="脱离文档流"><a href="#脱离文档流" class="headerlink" title="脱离文档流"></a>脱离文档流</h3><ul><li>浮动：<span class="label label-info">float</span></li><li>定位：<span class="label label-info">position:absolute &#x2F; fixed</span></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dom事件模型和事件机制</title>
    <link href="/posts/41c8ebf3.html"/>
    <url>/posts/41c8ebf3.html</url>
    
    <content type="html"><![CDATA[<h2 id="Dom事件模型"><a href="#Dom事件模型" class="headerlink" title="Dom事件模型"></a>Dom事件模型</h2><p>Dom事件模型分为两种：<span class="label label-info">事件冒泡</span>和<span class="label label-info">事件捕获</span>，事件冒泡模型由微软提出，而事件捕获模型由网景提出。</p><p>事件冒泡：当一个元素上的事件被触发时，事件<strong>从事件源开始</strong>，<strong>往上冒泡直到页面的根元素</strong>，这一过程被称为事件冒泡（默认方式）</p><p>事件捕获：当一个元素上的事件被触发时，事件<strong>从页面的根元素开始</strong>，<strong>往下直到事件目标元素</strong>，这一过程被称为事件捕获</p><p>如图所示：</p><p><img src="https://alierq.coding.net/p/images/d/images/git/raw/master/hexo/202206031732613.png"></p><p class="note note-danger">注意：如果一个元素上既被添加了事件冒泡的的监听也被添加了事件捕获的监听，则是按照先捕获后冒泡的顺序执行监听的回调函数。</p><h2 id="Dom事件机制"><a href="#Dom事件机制" class="headerlink" title="Dom事件机制"></a>Dom事件机制</h2><h3 id="事件三要素"><a href="#事件三要素" class="headerlink" title="事件三要素"></a>事件三要素</h3><ul><li>事件源：事件触发的对象</li><li>事件类型：通过何种方式触发，常见有：点击、键盘按下抬起……</li><li>事件回调函数：在事件被触发的时候，需要执行的操作</li></ul><h3 id="事件的执行步骤"><a href="#事件的执行步骤" class="headerlink" title="事件的执行步骤"></a>事件的执行步骤</h3><ol><li>获取事件源</li><li>绑定事件</li><li>添加事件回调函数</li></ol><h3 id="事件的绑定"><a href="#事件的绑定" class="headerlink" title="事件的绑定"></a>事件的绑定</h3><h4 id="使用addEventListener-绑定"><a href="#使用addEventListener-绑定" class="headerlink" title="使用addEventListener()绑定"></a>使用addEventListener()绑定</h4><p>使用<code>addEventListener()</code>可以对不同元素进行不同事件类型的监听，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">div.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;div被点击了！&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>默认是监听事件冒泡，如果要监听事件捕获，要在<code>addEventListener()</code>参数中进行设置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">div.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;div被点击了！&#x27;</span>)<br>&#125;,<span class="hljs-literal">true</span>)  <span class="hljs-comment">// true开启事件捕获</span><br></code></pre></td></tr></table></figure><h4 id="其他绑定方式"><a href="#其他绑定方式" class="headerlink" title="其他绑定方式"></a>其他绑定方式</h4><h5 id="通过标签的事件属性绑定"><a href="#通过标签的事件属性绑定" class="headerlink" title="通过标签的事件属性绑定"></a>通过标签的事件属性绑定</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;fn()&#123;console.log(event)&#125;&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p class="note note-danger">注意：这种方式绑定的事件，可以通过event获取事件对象，但是不能通过this获取到事件源</p><h5 id="通过Dom对象的事件属性绑定"><a href="#通过Dom对象的事件属性绑定" class="headerlink" title="通过Dom对象的事件属性绑定"></a>通过Dom对象的事件属性绑定</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;按钮&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;btn&quot;</span>);</span><br><span class="language-javascript">    btn.<span class="hljs-property">onclick</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;通过Dom对象的事件属性绑定&quot;</span>);</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="事件的阻止"><a href="#事件的阻止" class="headerlink" title="事件的阻止"></a>事件的阻止</h3><h4 id="阻止默认事件"><a href="#阻止默认事件" class="headerlink" title="阻止默认事件"></a>阻止默认事件</h4><p>当一个事件发生时浏览器可能会有些默认的操作，例如：点击a标签会跳转、右键会弹出菜单等等，这时我们可以使用<code>event.preventDefault();</code>阻止事件的默认行为。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">x.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;wheel&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">e</span>)=&gt;</span>&#123;  <span class="hljs-comment">//阻止滚动事件</span><br>    e.<span class="hljs-title function_">preventDefault</span>()<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="阻止事件冒泡"><a href="#阻止事件冒泡" class="headerlink" title="阻止事件冒泡"></a>阻止事件冒泡</h4><p>在某些特定的情况下，我们不希望事件持续冒泡到根元素，这个时候可以使用<code>event.stopPropagation()</code>去阻止事件继续冒泡。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">div.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;div3&quot;</span>);<br>    e.<span class="hljs-title function_">stopPropagation</span>(); <span class="hljs-comment">// 阻止事件继续冒泡</span><br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>利用事件冒泡或者事件捕获机制，通过给父元素绑定事件，从而实现对所有子元素的事件的管理，无需为每个子元素绑定事件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 因为事件冒泡，所以在点击li标签的时候会触发ul的单击事件</span><br><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;ul&quot;</span>).<span class="hljs-property">onclick</span> =   <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">target</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-comment">// e是事件对象</span><br>    <span class="hljs-comment">// e.target是事件对象（用户操作的元素）</span><br>    <span class="hljs-comment">// this是e.currentTarget （绑定监听的元素）</span><br>    <span class="hljs-comment">// 当点击的就是本身时，e.target和this没有区别</span><br>    <span class="hljs-comment">// 但是当点击的不是本身，点击的是子标签，然后通过事件冒泡得到的事件，</span><br>    <span class="hljs-comment">// 这时e.target!=this</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">innerText</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>优点：</p><ul><li>减少事件的注册，降低内存占用</li><li>新增元素时能够动态绑定事件</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jQuery的设计思想</title>
    <link href="/posts/171faadf.html"/>
    <url>/posts/171faadf.html</url>
    
    <content type="html"><![CDATA[<h2 id="jQuery获取元素"><a href="#jQuery获取元素" class="headerlink" title="jQuery获取元素"></a>jQuery获取元素</h2><h3 id="CSS选择器方式"><a href="#CSS选择器方式" class="headerlink" title="CSS选择器方式"></a>CSS选择器方式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-variable language_">document</span>) <span class="hljs-comment">// 选取整个文档对象</span><br><br>$(<span class="hljs-string">&#x27;#mydiv&#x27;</span>) <span class="hljs-comment">// 选择id为mydiv的元素</span><br><br>$(<span class="hljs-string">&#x27;.tt&#x27;</span>) <span class="hljs-comment">// 选择class为tt的元素</span><br><br>$(<span class="hljs-string">&#x27;input[name=username]&#x27;</span>) <span class="hljs-comment">// 选择name属性为username的input元素</span><br></code></pre></td></tr></table></figure><h3 id="jQuery特有表达式"><a href="#jQuery特有表达式" class="headerlink" title="jQuery特有表达式"></a>jQuery特有表达式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&#x27;a:first&#x27;</span>) <span class="hljs-comment">// 选择页面中第一个a元素</span><br><br>$(<span class="hljs-string">&#x27;tr:odd&#x27;</span>) <span class="hljs-comment">// 选择表格的奇数行</span><br><br>$(<span class="hljs-string">&#x27;#myForm :input&#x27;</span>) <span class="hljs-comment">// 选取id为myForm中的input元素</span><br><br>$(<span class="hljs-string">&#x27;div:visible&#x27;</span>) <span class="hljs-comment">// 选择可见的div元素</span><br><br>$(<span class="hljs-string">&#x27;div:gt(2)&#x27;</span>) <span class="hljs-comment">// 选择所有的div元素，除了前三个（0、1、2）</span><br><br>$(<span class="hljs-string">&#x27;div:animated&#x27;</span>) <span class="hljs-comment">// 选择当前处于动画状态的div元素</span><br></code></pre></td></tr></table></figure><h2 id="jQuery的链式操作"><a href="#jQuery的链式操作" class="headerlink" title="jQuery的链式操作"></a>jQuery的链式操作</h2><p>在jQuery中使用了<span class="label label-info">链式操作</span>，就是在你获取网页元素之后，可以连续对他进行一列的操作，并且这一系列的操作可以连续的写在一起，就好像链条一样。</p><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&#x27;#mydiv&#x27;</span>).<span class="hljs-title function_">find</span>(<span class="hljs-string">&#x27;span&#x27;</span>).<span class="hljs-title function_">eq</span>(<span class="hljs-number">2</span>).<span class="hljs-title function_">html</span>(<span class="hljs-string">&#x27;Hello World!&#x27;</span>);<br></code></pre></td></tr></table></figure><p>将其分解之后：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&#x27;#mydiv&#x27;</span>) <span class="hljs-comment">// 获取到id为mydiv的元素</span><br><br>    .<span class="hljs-title function_">find</span>(<span class="hljs-string">&#x27;span&#x27;</span>) <span class="hljs-comment">// 在他的内部寻找span标签</span><br><br>    .<span class="hljs-title function_">eq</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">// 获取span标签中的第3个(下标从0开始)</span><br><br>    .<span class="hljs-title function_">html</span>(<span class="hljs-string">&#x27;Hello World!&#x27;</span>); <span class="hljs-comment">// 将它的内容改为&#x27;Hello World!&#x27;</span><br></code></pre></td></tr></table></figure><p>每一次的jQuery操作，都会返回一个jQuery对象，下一个操作就可以直接在前一个操作的基础之上进行。</p><p>此外jQuery还提供了<a href="https://www.jquery123.com/end/">.end()</a>方法，返回上一个操作的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&#x27;#mydiv&#x27;</span>) <span class="hljs-comment">// 获取到id为mydiv的元素</span><br><br>    .<span class="hljs-title function_">find</span>(<span class="hljs-string">&#x27;span&#x27;</span>) <span class="hljs-comment">// 在他的内部寻找span标签</span><br><br>    .<span class="hljs-title function_">eq</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">// 获取span标签中的第3个(下标从0开始)</span><br><br>    .<span class="hljs-title function_">html</span>(<span class="hljs-string">&#x27;Hello World!&#x27;</span>); <span class="hljs-comment">// 将它的内容改为&#x27;Hello World!&#x27;</span><br><br><span class="hljs-comment">// 此时操作的对象是mydiv下的第3个span元素</span><br><br>.<span class="hljs-title function_">end</span>() <span class="hljs-comment">// 返回上一个操作对象</span><br><br><span class="hljs-comment">// 此时操作的对象是mydiv下的所有span元素</span><br></code></pre></td></tr></table></figure><h2 id="jQuery创建元素"><a href="#jQuery创建元素" class="headerlink" title="jQuery创建元素"></a>jQuery创建元素</h2><p>jQuery创建元素只需要把新元素以字符串的形式传入jQuery的构造构造函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&#x27;&lt;div&gt;Hello World!&lt;/div&gt;&#x27;</span>)<br><br>$(<span class="hljs-string">&#x27;&lt;li&gt;new li&lt;/li&gt;&#x27;</span>)<br><br><span class="hljs-comment">// 还可以使用append创建之后直接插入</span><br><br>$(<span class="hljs-string">&#x27;ul&#x27;</span>).<span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;&lt;li&gt;li&lt;/li&gt;&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="jQuery移动元素"><a href="#jQuery移动元素" class="headerlink" title="jQuery移动元素"></a>jQuery移动元素</h2><p>jQuery移动元素提供了两种方法：</p><p>假定我们想要将div元素放在p元素后面</p><p>第一种：直接移动该元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-title function_">insertAfter</span>($(<span class="hljs-string">&#x27;p&#x27;</span>))  <span class="hljs-comment">// 将div元素移动到p元素后面</span><br></code></pre></td></tr></table></figure><p>第二种：移动其他元素的位置，从而达到目的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&#x27;p&#x27;</span>).<span class="hljs-title function_">after</span>($(<span class="hljs-string">&#x27;div&#x27;</span>))  <span class="hljs-comment">// 在p元素的后面加入一个div</span><br></code></pre></td></tr></table></figure><p>两者实现的效果是相同的，但是第一种方法返回的对象是div元素，第二种方法返回的是p元素。</p><p>这类操作方法，一共有四对：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 在现存元素的外部，从后面插入元素</span><br>$(<span class="hljs-string">&#x27;xxx&#x27;</span>).<span class="hljs-title function_">insertAfter</span>()<br>$(<span class="hljs-string">&#x27;xxx&#x27;</span>).<span class="hljs-title function_">after</span>()<br><br><span class="hljs-comment">// 在现存元素的外部，从前面插入元素</span><br>$(<span class="hljs-string">&#x27;xxx&#x27;</span>).<span class="hljs-title function_">insertBefore</span>()<br>$(<span class="hljs-string">&#x27;xxx&#x27;</span>).<span class="hljs-title function_">before</span>()<br><br><span class="hljs-comment">// 在现存元素的内部，从后面插入元素</span><br>$(<span class="hljs-string">&#x27;xxx&#x27;</span>).<span class="hljs-title function_">appendTo</span>()<br>$(<span class="hljs-string">&#x27;xxx&#x27;</span>).<span class="hljs-title function_">append</span>()<br><br><span class="hljs-comment">// 在现存元素的内部，从前面插入元素</span><br>$(<span class="hljs-string">&#x27;xxx&#x27;</span>).<span class="hljs-title function_">prependTo</span>()<br>$(<span class="hljs-string">&#x27;xxx&#x27;</span>).<span class="hljs-title function_">prepend</span>()<br></code></pre></td></tr></table></figure><h2 id="jQuery修改元素属性"><a href="#jQuery修改元素属性" class="headerlink" title="jQuery修改元素属性"></a>jQuery修改元素属性</h2><p>jQuery中使用同意个函数进行取值（getter）和赋值（setter），具体是取值还是赋值由函数的参数决定</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-property">html</span>; <span class="hljs-comment">// 无参，获取div的值</span><br><br>$(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-property">html</span>; <span class="hljs-comment">// 带参，设置div的值 </span><br></code></pre></td></tr></table></figure><p>常用赋值和取值操作如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&#x27;xxx&#x27;</span>).<span class="hljs-title function_">html</span>() <span class="hljs-comment">// 取出或设置html内容</span><br><br>$(<span class="hljs-string">&#x27;xxx&#x27;</span>).<span class="hljs-title function_">text</span>() <span class="hljs-comment">// 取出或设置text内容</span><br><br>$(<span class="hljs-string">&#x27;xxx&#x27;</span>).<span class="hljs-title function_">attr</span>() <span class="hljs-comment">// 取出或设置某个属性的值</span><br><br>$(<span class="hljs-string">&#x27;xxx&#x27;</span>).<span class="hljs-title function_">width</span>() <span class="hljs-comment">// 取出或设置某个元素的宽度</span><br><br>$(<span class="hljs-string">&#x27;xxx&#x27;</span>).<span class="hljs-title function_">height</span>() <span class="hljs-comment">// 取出或设置某个元素的高度</span><br><br>$(<span class="hljs-string">&#x27;xxx&#x27;</span>).<span class="hljs-title function_">val</span>() <span class="hljs-comment">// 取出某个表单元素的值</span><br></code></pre></td></tr></table></figure><p>有一点需要注意，在<span class="label label-info">$(‘xxx’)</span>获取的值是多个时，在进行赋值的时候，是对所有元素进行赋值；在进行取值的时候，只对第一个元素进行取值（<a href="https://www.jquery123.com/text/">.text()</a>除外，它是取出所有元素text内容）。</p>]]></content>
    
    
    
    <tags>
      
      <tag>jQuery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>命令行常用操作</title>
    <link href="/posts/bf840e6a.html"/>
    <url>/posts/bf840e6a.html</url>
    
    <content type="html"><![CDATA[<h3 id="文件查看操作"><a href="#文件查看操作" class="headerlink" title="文件查看操作"></a>文件查看操作</h3><h4 id="查看文件路径"><a href="#查看文件路径" class="headerlink" title="查看文件路径"></a>查看文件路径</h4><p><code>pwd</code>：查看当前目录的绝对路径</p><p><code>ls</code>：查看当前目录内容</p><p><code>ls 路径</code>：查看指定目录内容</p><h4 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h4><p><code>cat 路径</code>  ：会显示文件的所有内容</p><p><code>head 路径</code>：只显示文件的前10行     </p><p>​<code>-n 行数</code>：控制查看行数</p><p><code>tail 路径</code>：只显示文件的后10行</p><p>​<code>-n 行数</code>：控制查看行数</p><p><code>less 路径</code>：进入一个可以滚动的界面 （q键退出）</p><h3 id="文件增加操作"><a href="#文件增加操作" class="headerlink" title="文件增加操作"></a>文件增加操作</h3><p><code>touch 文件名</code>：创建空文件</p><p><code>echo 内容</code>：打印内容</p><p><code>echo 内容 &gt; 文件名</code>：将内容放在文件中（文件存在会覆盖文件原有的内容，文件不存在会新建文件然后放入内容）</p><p><code>echo 内容 &gt;&gt; 文件名</code>：将内容追加在文件中</p><p><code>echo  -e &quot;内容(可包含转义字符)&quot;  &gt;&gt; 文件名</code> ：追加文本中使用转义字符（双引号不能少）</p><p><code>mkdir 文件夹名称1 文件夹名称2</code>：新建文件夹，多个文件夹用空格隔开</p><p><code>mkdir -p a/b/c/d/e</code>：创建多层目录（若有多个用空格隔开）</p><p><code>cp 1.txt  2.txt</code> ：将文件1拷贝成文件2</p><p><code>cp -r a b</code>：将a目录复制成b目录</p><h3 id="文件删除操作"><a href="#文件删除操作" class="headerlink" title="文件删除操作"></a>文件删除操作</h3><p><code>rm 1.txt</code>：删除文件 1.txt</p><p><code>rm -r a</code>：删除文件目录a</p><p>​<code>-f</code>：强制执行</p><h3 id="文件修改操作"><a href="#文件修改操作" class="headerlink" title="文件修改操作"></a>文件修改操作</h3><p><code>code 文件名</code>：使用默认编辑器打开这个文件进行编辑</p><p><code>start 文件名</code>：使用对应默认的软件打开</p><p><code>echo 内容 &gt;&gt; 文件名</code>：向文件中追加内容</p><p><code>echo &#39;&#39; &gt; 1.txt</code>：清空文件内容（使用echo添加一个空字符串）</p><p><code>mv 1.txt a</code>：将1.txt放入a目录中</p><p><code>mv b/1.txt .</code>：将b文件夹中的1.txt放入当前目录中</p><p><code>mv 1.txt 2.txt</code>：将1.txt重命名为2.txt</p><p><code>touch  1.txt</code> ：更新文件修改时间为当前时间</p><h3 id="脚本文件"><a href="#脚本文件" class="headerlink" title="脚本文件"></a>脚本文件</h3><p><code>a命令内容  &amp;&amp;  b命令内容</code>：a命令内容执行成功之后执行b命令内容</p><p><code>a命令内容; b命令内容</code>：a命令内容执行之后执行b命令内容（a命令不一定需要成功）</p><h4 id="创建一个脚本"><a href="#创建一个脚本" class="headerlink" title="创建一个脚本"></a>创建一个脚本</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/usr/bin/env sh</span><br><span class="hljs-built_in">mkdir</span> x<br><span class="hljs-built_in">cd</span> x<br><span class="hljs-built_in">touch</span> index.html<br><span class="hljs-built_in">touch</span> style.css<br><span class="hljs-built_in">touch</span> main.js<br><span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;追加\n内容&quot;</span> &gt;&gt; index.html<br></code></pre></td></tr></table></figure><h4 id="添加可执行权限"><a href="#添加可执行权限" class="headerlink" title="添加可执行权限"></a>添加可执行权限</h4><p>windos可以不用，但是在mac和linux下要做</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">chmod</span> +x 脚本文件名<br></code></pre></td></tr></table></figure><h4 id="执行脚本"><a href="#执行脚本" class="headerlink" title="执行脚本"></a>执行脚本</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">./脚本文件名<br>or<br>sh 脚本文件名<br></code></pre></td></tr></table></figure><p>注意：要加.&#x2F;否则不知道脚本文件的位置</p><h4 id="可接受参数脚本"><a href="#可接受参数脚本" class="headerlink" title="可接受参数脚本"></a>可接受参数脚本</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/usr/bin/env sh</span><br><span class="hljs-built_in">mkdir</span> <span class="hljs-variable">$1</span><br><span class="hljs-built_in">cd</span> <span class="hljs-variable">$1</span><br><span class="hljs-built_in">touch</span> index.html<br><span class="hljs-built_in">touch</span> style.css<br><span class="hljs-built_in">touch</span> main.js<br><span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;追加\n内容&quot;</span> &gt;&gt; index.html<br></code></pre></td></tr></table></figure><p><code>$1</code>表示接收到的第一个参数</p>]]></content>
    
    
    
    <tags>
      
      <tag>Bash</tag>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
